The "src" package contains sub-packages for each problem. Within each subpackage, there is a main class with a "main" method, where the code can be compiled and executed.

The "Helpers" package contains several helper classes for exporting data, printing, testing, timing, and performing calculations.

Note that when creating vertices in a graph, they are labeled from 0 to n-1 where n is the number of vertices. This is done to avoid confusion with the indices of the array. For example, if we have a graph with 5 vertices, the vertices will be labeled from 0 to 4. This labeling is done in the constructor of the graph class.- Problem 1
- Problem 1
    - The package contains all the classes required to create a graph. The "Graph" class is a superclass, and "UndirectedGraph" and "DirectedGraph" inherit from it. Additionally, both graph subclasses contain their own methods for adding and removing edges. The package also includes "Vertex" and "Edge" classes that are used in all further problems. Iterators can be found in a subpackage within Problem 1. Note that when using an iterator for edges, in an undirected graph, the edges are printed twice since the graph is undirected and the edges are bidirectional. This can be easily modified with the "Tuple" class, where the "equals" method is overridden to compare the edges and decide if they are the same. However, I did not make this modification to avoid confusion. Both graphs can be tested in a "Main" class with different operations. Iterators can also be tested in the "Main" class, as I have already created the objects within the "Main" class.
- Problem 2
    - "BFS" and "DFS" objects can be created with the graph included as a parameter and a starting vertex. Both search classes have two constructors. In the first one, the search is automatically called after creating the object. With the second constructor, the search is called by invoking the "bfs" or "dfs" methods. This is required since for the further tasks, I needed to reuse the searches and had to perform several searches, so the "bfs" or "dfs" methods had to be called multiple times.- Problem 3
- Problem 3
    - In the main method, create a graph object and pass it to the constructor of the "Kruskal" class. The "kruskal.createMinSpanningForest" method creates and prints the complete minimum spanning forest (or tree, depending on the input).- Problem 4
- Problem 4
    - In the main method, create a graph object and pass it to the constructor of the "Dijkstra" class or "Bellman-Ford" class, as well as the starting vertex. Then, call the "findShortestPath" method on the objects. The "findShortestPath" method prints the table with the shortest paths from the starting vertex to all other vertices. The "findShortestPathTo" method prints the shortest path from the starting vertex to all the vertices that can be reached from the starting vertex.- Problem 5
- Problem 5
    - In the main method, a graph is first created from the "data.txt" file with the help of the "GraphCreator" object, which reads the file and creates vertices and edges. Additionally, it maps course names with numbers starting from 0 to use them as vertices. Then, a topological sort object is created with the graph as a parameter within the constructor, and it performs the "topsort" operation on the graph, assigning the "topNum" to each vertex. Then, vertices are simply sorted by their "topNum," and courses are printed from the map based on the sorting previously - Problem 6
- Problem 6
    - In the main method, a graph can be created, and then the "BridgeFinder" object with the graph as a parameter. Then, "bridgeFinder.isBridge()" takes in a graph, starting vertex, and target vertex from the graph, and returns true or false depending on whether the given edge is a bridge or not.
